/**                                   5
 * @file public/pilot_nt.h
 * @author A. Brik, S. Papazov
 * @date 12 June 2016
 * @brief Public API for pilot_nt.dll.
 */
#ifndef _PILOT_NT_H_
#define _PILOT_NT_H_

#include <windows.h>

#ifdef UPOS
  #include "global.h"
  #include "public/paramsln.h"
  #define PILOT_NT_API __declspec(dllexport)
#else
  #include "paramsln.h"
  #define PILOT_NT_API __declspec(dllimport)
#endif

#ifdef __cplusplus
extern "C"{
#endif
/** @mainpage Основные сведения
  Для обслуживания банковских карт Сбербанк предоставляет программную библиотеку PILOT_NT.DLL,
  обеспечивающую проведение авторизаций по картам, а также формирование карточных чеков и итоговых отчетов за день.
  Для работы с картами кассовый аппарат оснащается дополнительным внешним устройством – ПИН-клавиатурой.
  Это устройство используется для считывания карт, для ввода ПИН-кода клиентом, а также выполняет функции
  криптографической защиты при обмене данными с процессинговой системой Сбербанка. ПИН-клавиатура может
  подключаться к СОМ-порту, порту USB или по протоколу ТТК2 через Ethernet Tcp/Ip. Сбербанк предоставляет
  это устройство бесплатно на период действия договора эквайринга с торговым предприятием.
  Если кассовый аппарат (ККМ) оснащен собственным ридером для магнитной полосы, то в период первоначальной
  разработки/отладки кассового ПО можно обойтись без ПИН-клавиатуры. Для окончательного тестирования (а также
  для реальной работы в торговом предприятии) ПИН-клавиатура понадобится обязательно.
*/

/** @page page2 Порядок вызова функций библиотеки
При оплате (возврате) покупки по банковской карте кассовая программа должна вызвать из библиотеки Сбербанка функцию card_authorize(), заполнив поля TType и Amount и указав нулевые значения в остальных полях. 
По окончании работы функции необходимо проанализировать поле RCode. Если в нем содержится значение «0» или «00», авторизация считается успешно выполненной, в противном случае – отклоненной.
Кроме этого, необходимо проверить значение поля Check. Если оно не равно NULL, его необходимо отправить на печать (в нефискальном режиме) и затем удалить вызовом функции GlobalFree().
При закрытии смены кассовая программа должна вызвать из библиотеки Сбербанка функцию close_day(), заполнив поле TType = 7 и указав нулевые значения в остальных полях.
По окончании работы функции необходимо проверить значение поля Check. Если поле Check не равно NULL, его необходимо отправить на печать (в нефискальном режиме) и после этого удалить вызовом функции GlobaFree().
*/

/** @page page3 Выполнение платежа с аварийной отменой
В случае, если внешняя программа не обеспечивает гарантированной печати карточного чека из поля Check, она может использовать следующую логику:

 -# Выполнить функцию  card_authorize().
 -# После завершения работы функции card_authorize(), если транзакция выполнена успешно, вызвать функцию SuspendTrx() и приступить к печати чека.
 -# Если чек напечатан успешно, вызвать функцию CommitTrx().
 -# Если во время печати чека возникла неустранимая проблема, вызвать функцию RollbackTrx() для отмены платежа.
 -# Если в ходе печати чека произойдет зависание ККМ или сбой питания, то транзакция останется в «подвешенном» состоянии. При следующем сеансе связи с банком она автоматически отменится.

Для корректного выполнения операций с функцией аварийной отмены необходимо придерживаться следующих правил:
1. Функция SuspendTrx() должна вызываться, только если оплата завершилась успешно – если возвращен код ответа 0.
2. Если вызов функции SuspendTrx() завершился ошибкой, операция должна считаться не выполненной, RollbackTrx() или CommitTrx() не должны вызываться. 
   Если необходимо отменить операцию – то только ручной обработкой через письмо в банк с пояснением ситуации и приложением имеющихся документов. 
   Причинами ошибок при выполнении функции SuspendTrx() могут быть:
   -# Не верная сумма операции (см. п 4.);
   -# Отсутствие связи с пинпадом;
   -# Ошибки в системном ПО пинпада (например, сбой файловой системы).
3. Функции CommitTrx() или RollbackTrx() должны вызываться, только если был успешный вызов SuspendTrx().
4. В функции SuspendTrx(), CommitTrx(), RollbackTrx() обязательно должна передаваться корректная сумма операции.
5. Если касса работает по описанному выше алгоритму и функция CommitTrx() вернет ошибку – откатываем операцию на кассе, 
   товар не отдаем, если клиент считает, что деньги списаны – предлагаем клиенту написать претензию или сами пишем в 
   Сбербанк с просьбой отменить операцию.
6. Если касса работает по описанному выше алгоритму и функция RollbackTrx() вернет ошибку – необходимо обратиться 
   в Сбербанк с информацией об операциях (чеки, контрольные ленты) c просьбой отменить эту операцию.
7. Авариная отмена предназначена только для операции «Оплата».

Например:
@code
//оплата на 10 руб (1000 коп).
struct auth_answer aa;
memset(&aa, 0, sizeof(aa));
aa.TType=OP_PURCHASE;
aa.Amount=1000;
carderr=card_authorize(NULL, &aa);
if (carderr==0){
	carderr = SuspendTrx(1000, NULL);	
	//если carderr!=0, считаем операцию не выполненной, 
	//CommitTrx() или RollbackTrx() не вызываем товар не отдаем, если клиент считает, что 
	//деньги списаны предлагаем клиенту написать претензию или сами пишем в 
	//Сбербанк с просьбой отменить операцию	
	if (действия кассы по печати чека, сохранению операции и т.п. успешны){
		if (carderr==0){
			carderr=CommitTrx(1000, NULL);
			if (carder!=0){ 
				//Отменяем операцию на кассе, товар не отдаем, если клиент считает, 
				//что деньги списаны предлагаем клиенту написать претензию или сами пишем в Сбербанк с просьбой отменить операцию 
			}
		}
		//если carderr!=0, то подтверждать не надо, т.к. suspend отработал с ошибкой.
	}else{ 
		// действия кассы по печати чека, сохранению операции и т.п. НЕ УСПЕШНЫ
		if (carderr==0){
			carderr=RollbackTrx(1000, NULL);
			if (carderr!=0){
				//пишем письмо в Сбербанк с просьбой отменить эту операцию
			}
		}else{
			//пишем письмо в Сбербанк с просьбой отменить эту операцию (см. п.2)
		}
	}
}
//Не забываем освободить поле auth_answer::Check
if (aa.Check)
	::GlobalFree((HGLOBAL)aa.Check);
@endcode
*/


/** @page page4 Выполнение операций без карты
  Операции возврат, отмена, завершение расчета или отмена предавторизации могут быть выполнены без считывания карты клиента. Это возможно,
  если исходные операции находятся в той же смене. Для проведения таких операций терминал должен быть соответствующим образом зарегистрирован 
  в процессинговой системе Сбербанка и настроен. Выполнение операций возможно только на тех версиях функций card_authorize(), которые принимают RRN в качестве параметра.

  При выполнении операции возврат без карты терминал:
  -# Выполнит полную отмену, если сумма возврата равна сумме исходной операции.
  -# Выполнит частичную отмену , если сумма возврата меньше суммы исходной операции и настройки терминала позволяют частичные отмены.
  -# Вернет код ошибки 4118 "Операции не найдены", если сумма превышает сумму исходной операции. 
  -# Может быть отменена любая операция, за исключением подтверждения взноса наличных и отмены предавторизации.
  -# Частичные отмены возможны только для операции оплата. Для всех остальных операций частичная отмена невозможна.
  -# В цепочке из предавторизации и нескольких добавочных предавторизаций допускается полная отмена любой из добавочных предавторизаций. Отмена основной предавторизации
     без отмены добавочных предавторизаций невозможна.
  
  Оплата бонусами «Спасибо», выполненная самим терминалом, а не кассовым ПО, не может быть отменена полностью или частично. Для таких операции допускается только возврат, 
  поэтому при попытке выполнить возврат без карты по такой операции терминал вернет ошибку 4118. Данное ограничение действует, если терминал самостоятельно выполняет
  обработку бонусов "Спасибо", без возврата в кассовое ПО промежуточного кода ответа 4353. Ограничение не распространяется на ваше ПО, если оно получает от терминала 
  промежуточный код ответа 4353, передает хэш карты на сервер "Спасибо" и уменьшает сумму операции при повторном вызове card_authorize().
  
  Для выполнения операций возврат, отмена, завершение расчета или отмена предавторизации без карты клиента при вызове функции card_authorize() должны быть указаны следующие параметры:
  -# Аргумент Track2 – должно содержать слово «QSELECT»;
  -# Поле Amount - сумма операции, если 0 – копируется из исходной операции и кассиру предлагается подтвердить или изменить сумму, если выполняемая операция это допускает. Для операции завершение расчета сумма не должна быть равна 0, для операции отмена предавторизации сумма должна быть равна 0;
  -# Поле RRN  - номер ссылки на исходную операцию.
  -# Поля Department и CurrencyCode, при их отличии от 0 , будут использоваться как дополнительный фильтр при поиске исходных операций. При их отсутствии терминал cкопирует из исходной операции код валюты и номер отдела

  Терминал вернет код ошибки 4118, если по переданным входным параметрам не сумеет найти исходную операцию. 

Например:
@code
//оплата на 1000 руб (100000 коп).
struct auth_answer14 aa;
char rrn[MAX_REFNUM];  //здесь сохраним номер ссылки между оплатой и возвратом

memset(&aa, 0, sizeof(aa));
memset(&rrn, 0, sizeof(rrn));

aa.TType=OP_PURCHASE;
aa.Amount=100000;
carderr=card_authorize14(NULL, &aa);

if (carderr==0){
  //сохраняем RRN
  strcpy(rrn, aa.RRN);
  //печатаем чек, отпускаем топливо
  //все оплаченное топливо не вошло в бак, клиент уехал
  //выполняем возврат без карты

  if (aa.Check)
    ::GlobalFree((HGLOBAL)aa.Check);

  memset(&aa, 0, sizeof(aa));
  aa.TType=OP_RETURN;
  aa.Amount=2000;       //возврат 20 руб
  strcpy(aa.RRN, rrn);  //исходная операция будет найдена по ее ссылочному номеру

  carderr=card_authorize14("QSELECT", &aa);
  if (carderr==0){
    //возврат успешен, оформляем его в учетной системе
  }else{
    //что-то пошло не так. Пишем письмо в Сбербанк с описанием ситуации и просьбой вернуть клиенту 20 руб
  }
}

//Не забываем освободить поле auth_answer::Check
if (aa.Check)
  ::GlobalFree((HGLOBAL)aa.Check);

@endcode
*/

/** @page page5 Уникальный идентификатор операции RequestID
  Значение RequestID может потребоваться для выполнения отправки торгового (кассового) чека в банк.
  
  Если это необходимо, то для финансовых операций следует использовать функции card_authorize11, card_authorize12, card_authorize13 и card_authorize14.
  Значение будет возвращено в поле RequestID структур auth_answer11, auth_answer12, auth_answer13, auth_answer14 соответственно.
  
  Например:
@code{.cpp}
  //оплата на 1000 руб (100000 коп).
  struct auth_answer14 aa;
  memset(&aa, 0, sizeof(aa));
  memset(&rrn, 0, sizeof(rrn));

  aa.TType=OP_PURCHASE;
  aa.Amount=100000;
  carderr=card_authorize14(NULL, &aa);

  if (carderr==0){
    //поле aa.RequestID содержит уникальный идентификатор
  }

  //Не забываем освободить поле auth_answer::Check
  if (aa.Check)
    ::GlobalFree((HGLOBAL)aa.Check);
@endcode
*/
/** @page page6 Отправка торгового чека в банк
  Для отправки торгового чека в банк, необходимо включить эту функцию в настройках терминала.
  Опция доступная в секции "Дополнительные настройки" и называется "Передавать чеки" (значение Да).
  Кроме того, терминал должен содержать "Вариант связи" с параметрами сервера чеков.
  По умолчанию опция выключена (аналогично значению "Передавать чеки" - Нет).
  После этого для каждой операции будет сохранена экранная подпись и банковский чек, а торговый можно будет отправить в терминал
  функцией ::AddMerchantCheque. Она же используется для отправки собранной формации в банк.
  Торговый чек должен быть передан в кодировке CP866.
  Алгоритм следующий:
  1. Выполнить финансовую операцию с получением идентификатора операции \ref page5 "RequestID".
  2. Запустить функцию ::AddMerchantCheque(<значение \ref page5 "RequestID">, <содержимое чека CP866>).
     Вызов этой функции обязателен, если торговый чек отсутствует или не требуется, то вторым аргументом следует указывать 0.
     При этом торговый чек, банковский чек и подпись клиента (при наличии) будут сохранены в терминале, но не переданы в банк.
  3. Рекомендуется отправлять чеки в банк каждую десятую операцию.
     Для этого нужно вызвать функцию ::AddMerchantCheque со значением первого и второго аргумента 0.
     @code{.cpp}
       AddMerchantCheque(0, 0);
     @endcode
  Если в терминале заканчивается свободное место, то финансовая операция, либо функция ::AddMerchantCheque вернут ошибку ::ERR_SEND_CHEQUES_TO_SERVER.
  Это значит, что следует немедленно отправить сохраненные в терминале чеки в банк.
  При большом количестве операций и торговых чеков, может быть сформировано несколько файлов для отправки в банк.
  Если после отправки в банк функция ::AddMerchantCheque вернула ошибку ::ERR_MORE_DATA, значит в терминале присутствует ещё один/несколько файлов для отправки, и операцию можно повторить пока не вернется 0.
  Если торговый чек по операции уже передан в терминал, то повторный вызов ::AddMerchantCheque с тем же \ref page5 "RequestID" вернет ошибку ::ERR_CHEQUE_ALREADY_PRESENT.
  Например:
@code{.cpp}
  //оплата на 1000 руб (100000 коп).
  struct auth_answer14 a;
  char merchantCheque[MERH_CHEQUE_SIZE];
  
  memset(&aa, 0, sizeof(a));
  //... выполнение финансовой операции
  aa.TType=OP_PURCHASE;
  aa.Amount=100000;
  carderr=card_authorize14(NULL, &aa);

  if (carderr==0){
    //заполнение торгового чека merchantCheque[]
    //...
    //отправка чека в терминал
    ::AddMerchantCheque(aa.RequestID, merchantCheque);
    //отправка накопленых чеков к банк
    ::AddMerchantCheque(0, 0);
}

  //Не забываем освободить поле auth_answer::Check
  if (aa.Check)
    ::GlobalFree((HGLOBAL)aa.Check);
@endcode
  Например: @see Docs\Для разработчиков ПО ККМ\\examples\\pilot_nt.dll\\cpp\\merh-cheque-to-host
*/


#pragma pack(1)

/** Идентификатор контекста операции */
typedef long CONTEXT_PTR;

/** Идентификаторы параметров, которые можно получить или передать через контекст операции */
typedef enum {
PAR_LLT_ID          = 1,    ///< [out] Номер программы лояльности в который попала карта, целое. Параметр возвращается при вызове функций ::card_authorize15 и ::ReadCardContext
PAR_PAN             = 2,    ///< [out] Маскированный номер карты, строка. Параметр возвращается при вызове функций ::ReadCardContext
PAR_HASH            = 3,    ///< [out] Хэш. Строка. Параметр возвращается функцией ::ReadCardContext
PAR_CARD_TYPE       = 4,    ///< [out] Тип карты. Целое. Параметр возвращается функцией ::ReadCardContext
PAR_OWN_CARD        = 5     ///< [out] Признак "Карта выпущена Сбербанком". Целое. Параметр возвращается функцией ::ReadCardContext
} EParameterName;



/**
 * @defgroup FINANCIAL Финансовые операции
 */
/**@{*/

/** Типы операций */
typedef enum {
OP_PURCHASE     = 1,   ///< Оплата покупки
OP_CASH         = 2,   ///< Выдача наличных (только ВСП)
OP_RETURN       = 3,   ///< Возврат либо отмена покупки
OP_BALANCE      = 4,   ///< Баланс (только ВСП)
OP_FUNDS        = 6,   ///< Безнал.перевод (только ВСП)
OP_ADD_AUTH     = 42,  ///< Добавочная предавторизация
OP_CANC_AUTH    = 43,  ///< Отмена предавторизации
OP_PREAUTH      = 51,  ///< Предавторизация
OP_COMPLETION   = 52,  ///< Завершение расчета
OP_CASHIN       = 53,  ///< Взнос наличных (только ВСП)
OP_CASHIN_COMP  = 54,  ///< Подтверждение взноса (только ВСП)
OP_PILOT_START  = 55,  ///< Начать сессию с клиентом (только ВСП)
OP_PILOT_STATUS = 56,  ///< Опрос наличия карты клиента (только ВСП)
OP_PILOT_STOP   = 57,  ///< Закончить сессию с клиентом (только ВСП)
OP_SETPIN       = 58,  ///< Установка ПИНа (только ВСП)
OP_CHANGEPIN    = 59,  ///< Смена ПИНа (только ВСП)
} OpetationTypes;

/**
 * Основные параметры операции
 * Структура, используемая для описания операции и получения результатов выполнения операции.
 */
struct auth_answer{
   int TType;             /**< [in] тип транзакции. см ::OpetationTypes */
   unsigned long Amount;  /**< [in] сумма в копейках                    */
   char RCode[3];         /**< [out] код результата авторизации         */
   char AMessage[16];     /**< [out] текст результата авторизации       */
   int  CType;            /**< [in,out] тип карты                       */
   char* Check;           /**< [out] образ чека, должен освобождаться GlobalFree в вызывающей программе */
};

/** @brief Выполнение операций по картам
 *  @param[in] track2 данные дорожки карты с магнитной полосой. Если NULL, то будет предложено считать карту.
 *  @param[in,out] auth_answer Основные параметры операции. См. ::auth_answer
 *  @return int Код ошибки.
 */
PILOT_NT_API int card_authorize(char *track2, struct auth_answer *auth_answer);

/** @struct auth_answer2
 *  @brief Расширение для получения кода авторизации успешной операции.
 */
struct auth_answer2{
  struct auth_answer auth_answ;  /**< [in]  Основные параметры операции. См. ::auth_answer */
  char AuthCode[MAX_AUTHCODE];  /**< [out] Код авторизации. 7 байт.              */
};

/** @brief Выполнение операций по картам
 *  @param[out] track2 - данные дорожки карты с магнитной полосой. Если NULL, то будет предложено считать карту.
 *  @param[in,out] auth_answer - см. ::auth_answer2
 *  @return int Код ошибки.
 */
PILOT_NT_API int  card_authorize2(char *track2, struct auth_answer2 *auth_answer);

/** @struct auth_answer3
 *  @brief Расширение для получения кода авторизации успешной операции и номера карты.
 */
struct auth_answer3{
  struct auth_answer auth_answ; /**< [in, out]  Основные параметры операции. См. ::auth_answer */
  char AuthCode[MAX_AUTHCODE]; /**< [out] Код авторизации. 7 байт.                       */
  char CardID[CARD_ID_LEN];     /**< [out] Идентификатор карты. 25 байт. Для международных карт все символы, кроме первых 6 и последних 4, будут заменены символами ‘*’.*/
};

/** @brief Выполнение операций по картам
 *  @param[in] track2 данные дорожки карты с магнитной полосой. Если NULL, то будет предложено считать карту.
 *  @param[in,out] auth_answer см. ::auth_answer3
 *  @return int Код ошибки.
 */
PILOT_NT_API int  card_authorize3(char *track2, struct auth_answer3 *auth_answer);

/** @struct auth_answer4
 *  @brief Расширение для получения кода авторизации успешной операции, номера карты, кода ответа, времени операции и номера операции на кассе.
 */
struct auth_answer4{
  struct auth_answer auth_answ; /**< [in, out]  Основные параметры операции. См. ::auth_answer */
  char AuthCode[MAX_AUTHCODE]; /**< [out] Код авторизации. 7 байт.                            */
  char CardID[CARD_ID_LEN];     /**< [out] Идентификатор карты. 25 байт.                       */
  int  ErrorCode;               /**< [out] Код ошибки.                                         */
  char TransDate[TRANSDATE_LEN];/**< [out] Дата и время операции                               */
  int  TransNumber;             /**< [out] Номер операции за опер. день, см. номер на чеке     */
};

/** @brief Выполнение операций по картам
 *  @param[in] track2 данные дорожки карты с магнитной полосой. Если NULL, то будет предложено считать карту.
 *  @param[in,out] auth_answer см. ::auth_answer4
 *  @return int Код ошибки.
 */
PILOT_NT_API int  card_authorize4(char *track2, struct auth_answer4 *auth_answer);

/** @struct auth_answer5
 *  @brief Расширение для получения кода авторизации успешной операции и номера ссылки (RRN).
 */
struct auth_answer5{
  struct auth_answer auth_answ;   /**< [in]  Основные параметры операции. См. ::auth_answer */
  char   RRN[MAX_REFNUM];         /**< [in,out] Номер ссылки операции, присвоенный хостом. Используется
                                                для операций возврат и множественной авторизации.
                                                Содержит уникальный 12-значный ссылочный номер.
                                                При предавторизации это поле является выходным
                                                (его заполняет библиотека pilot_nt.dll), а при
                                                завершении расчета – входным (значение должно 
                                                быть заполнено вызывающей программой; оно должно
                                                совпадать со значением, возвращенным при предавторизации).*/
  char   AuthCode[MAX_AUTHCODE]; /**< [out] Код авторизации. 7 байт.                       */
};

/** @brief Выполнение операций по картам
 *  @param[out] track2 - данные дорожки карты с магнитной полосой. Если NULL, то будет предложено считать карту.
 *  @param[in,out] auth_answer - см. ::auth_answer5
 *  @return int Код ошибки.
 */
PILOT_NT_API int  card_authorize5(char *track2, struct auth_answer5 *auth_answer);

/** @struct auth_answer6
 *  @brief Расширение для получения данных как при выполнении auth_answer5 и auth_answer4.
 */
struct auth_answer6{
  struct auth_answer auth_answ;    /**< [in, out]  Основные параметры операции. См. ::auth_answer  */
  char   AuthCode[MAX_AUTHCODE];  /**< [out] Код авторизации. 7 байт.                             */
  char   CardID[CARD_ID_LEN];      /**< [out] Идентификатор карты. 25 байт.                        */
  int    ErrorCode;                /**< [out] Код ошибки.                                          */
  char   TransDate[TRANSDATE_LEN]; /**< [out] Дата и время операции                                */
  int    TransNumber;              /**< [out] Номер операции за опер. день, см. номер на чеке      */
  char   RRN[MAX_REFNUM];          /**< [in,out] Номер ссылки операции, присвоенный хостом. Используется
                                                для операций возврат и множественной авторизации.
                                                Содержит уникальный 12-значный ссылочный номер.
                                                При предавторизации это поле является выходным
                                                (его заполняет библиотека pilot_nt.dll), а при
                                                завершении расчета – входным (значение должно 
                                                быть заполнено вызывающей программой; оно должно
                                                совпадать со значением, возвращенным при предавторизации).*/
};

/** @brief Выполнение операций по картам
 *  @param[in] track2 данные дорожки карты с магнитной полосой. Если NULL, то будет предложено считать карту.
 *  @param[in,out] auth_answer см. ::auth_answer6
 *  @return int Код ошибки.
 */
PILOT_NT_API int  card_authorize6(char *track2, struct auth_answer6 *auth_answer);

/** @struct payment_info_item
 *  @brief Элемент цепочки тэгов для передачи на сервер платежной системы
 */
struct payment_info_item{
  DWORD  dwTag;                   /**< Тег платежной системы. */
  char   Value[MAX_PAYMENT_ITEM]; /**< Значение тэга платежной системы. 128 байт. ::MAX_PAYMENT_ITEM */
  BYTE   Flags;                   /**< must be 0x40 for immediate sending */
  void*  pNextItem;               /**< Следующий элемент цепочки. В случае NULL, это последний элемент цепочки. */
};

/** @brief Выполнение операций по картам
 *  @param[in] track2 данные дорожки карты с магнитной полосой. Если NULL, то будет предложено считать карту.
 *  @param[in,out] auth_answer см. ::auth_answer6
 *  @param[in,out] payinfo см. ::payment_info_item
 *  @return int Код ошибки.
 */
PILOT_NT_API int  card_authorize6_ext(
  char *track2,
  struct auth_answer6 *auth_answer,
  struct payment_info_item *payinfo
);

/** @struct auth_answer7
 *  @brief Расширение для получения кода авторизации успешной операции, номера карты и признака принадлежности карты Сбербанку.
 */
struct auth_answer7{
  struct auth_answer auth_answ;    /**< [in, out]  Основные параметры операции. См. ::auth_answer */
  char   AuthCode[MAX_AUTHCODE];  /**< [out] Код авторизации. 7 байт.                            */
  char   CardID [CARD_ID_LEN];     /**< [out] Идентификатор карты. 25 байт.                       */
  int    SberOwnCard;              /**< [out] Флаг принадлежности карты Сбербанку                 */
};

/** @brief Выполнение операций по картам
 *  @param[in] track2 данные дорожки карты с магнитной полосой. Если NULL, то будет предложено считать карту.
 *  @param[in,out] auth_answer см. ::auth_answer7
 *  @return int Код ошибки.
 */
PILOT_NT_API int  card_authorize7(char *track2, struct auth_answer7 *auth_answer);


/** @struct auth_answer8
 *  @brief Расширение для получения данных как при выполнении auth_answer5 и auth_answer4, а также номера карты и срока действия в шифрованном виде.
 */
struct auth_answer8{
  struct auth_answer auth_answ;      /**< [in, out]  Основные параметры операции. См. ::auth_answer */
  char   AuthCode[MAX_AUTHCODE];    /**< [out] Код авторизации. 7 байт.                            */
  char   CardID[CARD_ID_LEN];        /**< [out] Идентификатор карты. 25 байт.                       */
  int    ErrorCode;                  /**< [out] Код ошибки.                                         */
  char   TransDate[TRANSDATE_LEN];   /**< [out] Дата и время операции                               */
  int    TransNumber;                /**< [out] Номер операции за опер. день, см. номер на чеке     */
  char   RRN[MAX_REFNUM];            /**< [in,out] Номер ссылки операции, присвоенный хостом. Используется
                                                для операций возврат и множественной авторизации.
                                                Содержит уникальный 12-значный ссылочный номер.
                                                При предавторизации это поле является выходным
                                                (его заполняет библиотека pilot_nt.dll), а при
                                                завершении расчета – входным (значение должно 
                                                быть заполнено вызывающей программой; оно должно
                                                совпадать со значением, возвращенным при предавторизации).*/
  char   EncryptedData[MAX_ENCR_DATA*2+1]; /**< [in, out] шифрованный номер карты и срок действия. Не реализован для протокола ТТК.   */
};
/** @brief Выполнение операций по картам
 *  @note Функция удваивает количество воззвращаемых чеков. При работе по протоколу ТТК поле EncryptedData не заполняется.
 *  @param[in] track2 данные дорожки карты с магнитной полосой. Если NULL, то будет предложено считать карту.
 *  @param[in,out] auth_answer см. ::auth_answer8
 *  @return int Код ошибки.
 */
PILOT_NT_API int  card_authorize8(char *track2, struct auth_answer8 *auth_answer);

/** @struct preauth_rec
 *  @brief  Структура для описания одной операции в списке, по которой нужно выполнить завершение расчета.
 */
struct preauth_rec{
  unsigned long  Amount;          /**< [in] сумма в копейках              */
  char   RRN[MAX_REFNUM];         /**< [in,out] Номер ссылки операции, присвоенный хостом. Используется
                                                для операций возврат и множественной авторизации.
                                                Содержит уникальный 12-значный ссылочный номер.
                                                При предавторизации это поле является выходным
                                                (его заполняет библиотека pilot_nt.dll), а при
                                                завершении расчета – входным (значение должно
                                                быть заполнено вызывающей программой; оно должно
                                                совпадать со значением, возвращенным при предавторизации).*/
  char           Last4Digits[5];  /**< [in] последние 4 цифры номера карты*/
  unsigned short ErrorCode;       /**< [out] Код ошибки.                  */
};

/** @brief Выполнение операций по картам
 *  @param[in] track2 данные дорожки карты с магнитной полосой. Если NULL, то будет предложено считать карту.
 *  @param[in,out] auth_ans см. ::auth_answer8
 *  @param[in,out] pPreAuthList Массив структур с описанием, по которым требуется выполнить "Завершение расчета". См. ::preauth_rec
 *  @param[in] NumAuths Общее количество операций, по которым требуется выполнить "Завершение расчета".
 *  @return int Код ошибки.
 */
PILOT_NT_API int card_complete_multi_auth8(
  char* track2,
  struct auth_answer8* auth_ans,
  struct preauth_rec*  pPreAuthList,
  int NumAuths
);

/** @struct auth_answer9
*  @brief Расширение для получения кода авторизации успешной операции, номера карты, хеша номера карты и признака принадлежности карты Сбербанку.
 */
struct auth_answer9{
  auth_answer   ans;                     /**< [in, out]  Основные параметры операции. См. ::auth_answer */
  char          AuthCode[MAX_AUTHCODE]; /**< [out] Код авторизации. 7 байт.                            */
  char          CardID [CARD_ID_LEN];    /**< [out] Идентификатор карты. 25 байт.                       */
  int           SberOwnCard;             /**< [out] Флаг принадлежности карты Сбербанку                 */
  char          Hash[CARD_HASH_LEN];     /**< [in, out] хеш SHA1 от номера карты, в формате ASCII с нулевым байтом в конце. 40 байт.*/
};

/** @brief Выполнение операций по картам
 *  @param[in] track2 данные дорожки карты с магнитной полосой. Если NULL, то будет предложено считать карту.
 *  @param[in,out] auth_answer см. ::auth_answer9
 *  @return int Код ошибки.
 */
PILOT_NT_API int  card_authorize9(char *track2, struct auth_answer9 *auth_answer);

/** @struct auth_answer10
 *  @brief Расширение для получения данных как при выполнении auth_answer4, а также принадлежности карты Сбербанку
 *  и хеша от номера карты.
 */
struct auth_answer10{
  auth_answer   ans;               /**< [in, out]  Основные параметры операции. См. ::auth_answer */
  char   AuthCode[MAX_AUTHCODE];  /**< [out] Код авторизации. 7 байт.              */
  char   CardID[CARD_ID_LEN];      /**< [out] Идентификатор карты. 25 байт. Для международных карт все символы, кроме первых 6 и последних 4, будут заменены символами ‘*’.*/
  int    ErrorCode;                /**< [out] Код ошибки.                                         */
  char   TransDate[TRANSDATE_LEN]; /**< [out] Дата и время операции                               */
  int    TransNumber;              /**< [out] Номер операции за опер. день, см. номер на чеке     */
  int    SberOwnCard;              /**< [out] Флаг принадлежности карты Сбербанку                 */
  char   Hash[CARD_HASH_LEN];      /**< [in, out] хеш от номера карты, в формате ASCII с нулевым байтом в конце*/
};

/** @brief Выполнение операций по картам
 *  @param[in] track2 данные дорожки карты с магнитной полосой. Если NULL, то будет предложено считать карту.
 *  @param[in,out] auth_answer см. ::auth_answer10
 *  @return int Код ошибки.
 */
PILOT_NT_API int  card_authorize10(char *track2, struct auth_answer10 *auth_answer);

/** @struct auth_answer11
 *  @brief Расширение для получения кода авторизации успешной операции, номера карты, кода ответа,
 *         даты, времени и номера операции, хеша номера карты, признака принадлежности карты Сбербанку, третьей дорожки карты.
 
 */
struct auth_answer11{
  auth_answer   ans;               /**< [in, out]  Основные параметры операции. См. ::auth_answer */
  char   AuthCode[MAX_AUTHCODE];  /**< [out] Код авторизации. 7 байт.              */
  char   CardID[CARD_ID_LEN];      /**< [out] Идентификатор карты. 25 байт. Для международных карт все символы, кроме первых 6 и последних 4, будут заменены символами ‘*’.*/
  int    ErrorCode;                /**< [out] Код ошибки.                                         */
  char   TransDate[TRANSDATE_LEN]; /**< [out] Дата и время операции                               */
  int    TransNumber;              /**< [out] Номер операции за опер. день, см. номер на чеке     */
  int    SberOwnCard;              /**< [out] Флаг принадлежности карты Сбербанку                 */
  char   Hash[CARD_HASH_LEN];      /**< [in, out] хеш SHA1 от номера карты, в формате ASCII с нулевым байтом в конце. 40 байт.*/
  char   Track3[CARD_TRACK3_LEN];  /**< [out] Третья дорожка карты. Не используется в PCI DSS решениях*/
  unsigned long RequestID;         /**< [in,out] Уникальный номер операции. Только PCI DSS решения.*/
};

/** @brief Выполнение операций по картам
 *  @param[in] track2 данные дорожки карты с магнитной полосой. Если NULL, то будет предложено считать карту.
 *  @param[in,out] auth_answer см. ::auth_answer11
 *  @return int Код ошибки.
 */
PILOT_NT_API int  card_authorize11(char *track2, struct auth_answer11 *auth_answer);

/** @struct auth_answer12
 *  @brief Расширение card_authorize11 возможностью указать номер отдела и задать/получить номер ссылки.
 */
struct auth_answer12 {
  auth_answer   ans;              /**< [in, out]  Основные параметры операции. См. ::auth_answer */
  char   AuthCode[MAX_AUTHCODE]; /**< [out] Код авторизации. 7 байт.              */
  char   CardID[CARD_ID_LEN];     /**< [out] Идентификатор карты. 25 байт. Для международных карт все символы, кроме первых 6 и последних 4, будут заменены символами ‘*’.*/
  int    ErrorCode;               /**< [out] Код ошибки.                                         */
  char   TransDate[TRANSDATE_LEN];/**< [out] Дата и время операции                               */
  int    TransNumber;             /**< [out] Номер операции за опер. день, см. номер на чеке     */
  int    SberOwnCard;             /**< [out] Флаг принадлежности карты Сбербанку                 */
  char   Hash[CARD_HASH_LEN];     /**< [in, out] хеш SHA1 от номера карты, в формате ASCII с нулевым байтом в конце. 40 байт.*/
  char   Track3[CARD_TRACK3_LEN]; /**< [out] третья дорожка карты*/
  unsigned long RequestID;        /**< [in,out] Уникальный номер операции. Только PCI DSS решения.*/
  DWORD  Department;              /**< [in] Порядковый номер отдела от 0 до 14-ти, включительно.
                                            При установке номера отдела в 0xFFFFFFFF, номер отдела
                                            будет запрошен через интерфейс терминала после вставки карты.
                                            Если номер отдела будет указан вне настроенного диапазона,
                                            то терминал вернет код ошибки 4191. */
  char   RRN[MAX_REFNUM];         /**< [in,out] Номер ссылки операции, присвоенный хостом. Используется
                                                для операций возврат и множественной авторизации.
                                                Содержит уникальный 12-значный ссылочный номер.
                                                При предавторизации это поле является выходным
                                                (его заполняет библиотека pilot_nt.dll), а при
                                                завершении расчета – входным (значение должно 
                                                быть заполнено вызывающей программой; оно должно
                                                совпадать со значением, возвращенным при предавторизации).*/
};

/** @brief Выполнение операций по картам
 *  @param[in] track2 данные дорожки карты с магнитной полосой. Если NULL, то будет предложено считать карту.
 *  @param[in,out] auth_answer см. ::auth_answer12
 *  @return int Код ошибки.
 */
PILOT_NT_API int  card_authorize12(char *track2, struct auth_answer12 *auth_answer);

/** @struct auth_answer13
 *  @brief Расширение card_authorize11 возможностью указать номер отдела, код валюты и получить способ чтения карты, имя клиента карты и AID.
 */
struct auth_answer13{

  auth_answer   ans;              /**< [in, out]  Основные параметры операции. См. ::auth_answer */
  char   AuthCode[MAX_AUTHCODE]; /**< [out] Код авторизации. 7 байт.                       */
  char   CardID[CARD_ID_LEN];     /**< [out] Идентификатор карты. 25 байт. Для международных карт все символы, кроме первых 6 и последних 4, будут заменены символами ‘*’.*/
  int    ErrorCode;               /**< [out] Код ошибки.                                         */
  char   TransDate[TRANSDATE_LEN];/**< [out] Дата и время операции                               */
  int    TransNumber;             /**< [out] Номер операции за опер. день, см. номер на чеке     */
  int    SberOwnCard;             /**< [out] Флаг принадлежности карты Сбербанку                 */
  char   Hash[CARD_HASH_LEN];     /**< [in, out] хеш SHA1 от номера карты, в формате ASCII с нулевым байтом в конце. 40 байт.*/
  char   Track3[CARD_TRACK3_LEN]; /**< [out] третья дорожка карты*/
  DWORD  RequestID;               /**< [in,out] Уникальный номер операции. Только PCI DSS решения.*/
  DWORD  Department;              /**< [in] Порядковый номер отдела от 0 до 14-ти, включительно.
                                            При установке номера отдела в 0xFFFFFFFF, номер отдела
                                            будет запрошен через интерфейс терминала после вставки карты.
                                            Если номер отдела будет указан вне настроенного диапазона,
                                            то терминал вернет код ошибки 4191. */
  char   RRN[MAX_REFNUM];         /**< [in,out] Номер ссылки операции, присвоенный хостом. Используется
                                                для операций возврат и множественной авторизации.
                                                Содержит уникальный 12-значный ссылочный номер.
                                                При предавторизации это поле является выходным
                                                (его заполняет библиотека pilot_nt.dll), а при
                                                завершении расчета – входным (значение должно
                                                быть заполнено вызывающей программой; оно должно
                                                совпадать со значением, возвращенным при предавторизации).*/
  DWORD  CurrencyCode;            /**< [in] Международный код валюты (810, 643, 840, 978 и т.д.) */
  char   CardEntryMode;           /**< [out] Способ чтения карты ('D'-магн.полоса, 'M'-ручной ввод, 'C'-чип, 'E'-бесконтакт EMV, 'R'-бесконтакт magstripe, 'F'-fallback)*/
  char   CardName[MAX_CARD_NAME_LEN]; /**< [out] Название типа карты */
  char   AID[MAX_AID_ASCII_LEN];  /**< [out] Application ID чиповой карты (в виде ASCIIZ-строки)*/
  char   FullErrorText[MAX_FULL_ERROR_TEXT]; /**< [out] Полный текст сообщения об ошибке*/
};

/** @brief Выполнение операций по картам
 *  @param[in] track2 данные дорожки карты с магнитной полосой. Если NULL, то будет предложено считать карту.
 *  @param[in,out] auth_answer см. ::auth_answer13
 *  @return int Код ошибки.
 */
PILOT_NT_API int  card_authorize13(char *track2, struct auth_answer13 *auth_answer);

/** @struct auth_answer14
 *  @brief Расширение card_authorize13 возможностью указать информацию о товаре.
 */
struct auth_answer14 {
  auth_answer   ans;               /**< [in, out]  Основные параметры операции. См. ::auth_answer */
  char   AuthCode[MAX_AUTHCODE];  /**< [out] Код авторизации. 7 байт.              */
  char   CardID[CARD_ID_LEN];      /**< [out] Идентификатор карты. 25 байт. Для международных карт все символы, кроме первых 6 и последних 4, будут заменены символами ‘*’.*/
  int    ErrorCode;                /**< [out] Код ошибки.                                         */
  char   TransDate[TRANSDATE_LEN]; /**< [out] Дата и время операции                               */
  int    TransNumber;              /**< [out] Номер операции за опер. день, см. номер на чеке     */
  int    SberOwnCard;              /**< [out] Флаг принадлежности карты Сбербанку                 */
  char   Hash[CARD_HASH_LEN];      /**< [in, out] хеш SHA1 от номера карты, в формате ASCII с нулевым байтом в конце. 40 байт.*/
  char   Track3[CARD_TRACK3_LEN];  /**< [out] третья дорожка карты*/
  DWORD  RequestID;                /**< [in,out] Уникальный номер операции. Только PCI DSS решения.*/
  DWORD  Department;              /**< [in] Порядковый номер отдела от 0 до 14-ти, включительно.
                                            При установке номера отдела в 0xFFFFFFFF, номер отдела
                                            будет запрошен через интерфейс терминала после вставки карты.
                                            Если номер отдела будет указан вне настроенного диапазона,
                                            то терминал вернет код ошибки 4191. */
  char   RRN[MAX_REFNUM];          /**< [in,out] Номер ссылки операции, присвоенный хостом. Используется
                                                для операций возврат, множественной авторизации и завершения расчета.
                                                Содержит уникальный 12-значный ссылочный номер.
                                                При предавторизации это поле является выходным
                                                (его заполняет библиотека pilot_nt.dll), а при
                                                завершении расчета – входным (значение должно
                                                быть заполнено вызывающей программой; оно должно
                                                совпадать со значением, возвращенным при предавторизации).*/
  DWORD  CurrencyCode;             /**< [in] Международный код валюты (810, 643, 840, 978 и т.д.) */
  char   CardEntryMode;            /**< [out] Способ чтения карты ('D'-магн.полоса, 'M'-ручной ввод, 'C'-чип, 'E'-бесконтакт EMV, 'R'-бесконтакт magstripe, 'F'-fallback)*/
  char   CardName[MAX_CARD_NAME_LEN]; /**< [out] Название типа карты */
  char   AID[MAX_AID_ASCII_LEN];   /**< [out] Application ID чиповой карты (в виде ASCIIZ-строки). Не используется для PCI-DSS решений*/
  char   FullErrorText[MAX_FULL_ERROR_TEXT]; /**< [out] Полный текст сообщения об ошибке*/
  DWORD  GoodsPrice;                /**< [in] Цена за единицу товара, коп (34.99->3499)*/
  DWORD  GoodsVolume;               /**< [in] Количество товара, в тыс. долях (30.234->30234)*/
  char   GoodsCode[MAX_GOODS_CODE+1]; /**< [in] Код товара во внешней системе.*/
  char   GoodsName[MAX_GOODS_NAME]; /**< [in] Наименование товара во внешней системе. Внимание! В структуре auth_answer14 название товара на один символ короче чем в gate.dll TGoodsData. Зафиксируем эту ошибку как стандарт*/
};

/**@brief Структура для получения результатов запроса к мониторингу.
 *
 */
struct host_status_answer{
   DWORD size;                         /**< [out] Размер?         */
   DWORD MonState;                     /**< [out] Статус          */
   DWORD MonMessageType;               /**< [out] Тип             */
   char  MonMessage[MAX_MON_MSG];      /**< [out] Текст сообщения */
};

/** @brief Выполнение операций по картам
 *  @param[in] track2 данные дорожки карты с магнитной полосой. Если NULL, то будет предложено считать карту.
 *  @param[in,out] auth_answer см. ::auth_answer14
 *  @param[in,out] payinfo Информация для платежной системы
 *  @return int Код ошибки.
 */
PILOT_NT_API int  card_authorize14(
  char *track2,
  struct auth_answer14 *auth_answer,
  struct payment_info_item *payinfo
);


/** @brief Выполнение операций по картам
 *  @note Функция дополнительно принимает входной и выходной контексты операции. Во входном контексте в библиотеку передаются дополнительные параметры операции
 *  в выходном контексте возвращается расширенный результат операции. Параметры, которые могут переданы или получены через контекст операции
 *  перечислены в EParameterName.
 *  @param[in] track2 данные дорожки карты с магнитной полосой. Если NULL, то будет предложено считать карту.
 *  @param[in,out] auth_answer см. ::auth_answer14
 *  @param[in,out] payinfo Информация для платежной системы
 *  @param[in] dataIn см. ::ctxAlloc
 *  @param[in] dataOut см. ::ctxAlloc
 *  @return int Код ошибки.
 */
PILOT_NT_API int  card_authorize15(
  char *track2,
  struct auth_answer14 *auth_answer,
  struct payment_info_item *payinfo,
  CONTEXT_PTR dataIn,
  CONTEXT_PTR dataOut
);

/**@}*/

/**
 * @defgroup SERVICE Служебные операции
 */
/**@{*/

 /** @brief Получить номер терминала как строку
 *  @note Функция не поддерживается по протоколу TTK для PCI-DSS решений.
 *  @param[out] pTerminalID Строковое представление номера терминала. 9 байт.
 *  @return int Код ошибки.
 */
PILOT_NT_API int GetTerminalID(char* pTerminalID);

/** @brief Открыть в техническое меню на пинпаде
 *  @note По завершении поле auth_answer.Check может содержать образ документа для печати.
 *  @param[out] auth_answer Буфер результата операции
 *  @return int Код ошибки.
 */
PILOT_NT_API int ServiceMenu(struct auth_answer *auth_answer);

/** @brief Закрытие дня.
 *  @note  Поля TType, Amount, CType заполнять не нужно.
 *  @param[in,out] auth_answer см. ::auth_answer
 *  @return int Код ошибки.
 */
PILOT_NT_API int close_day(struct auth_answer *auth_answer);

/** @brief Закрытие дня.
 *  @note  Поля auth_answer::Amount и auth_answer::CType заполнять не нужно. Поле auth_answer::TType = 7.
 *  char* Check

Содержит образ отчета по картам, который вызывающая программа должна отправить на печать, а затем освободить вызовом функции GlobalFree().

Может иметь значение NULL. В этом случае никаких действий с ним вызывающая программа выполнять не должна.


 *  @param[in,out] auth_answer см. ::auth_answer
 *  @param[in,out] iParams Дополнительная информация для передачи на хост Сбербанка (например, о наличном обороте кассы за смену).
 *  В текущей версии поддерживается следующий формат строки:
 *  1;число_оплат_за_наличные;сумма_оплат_за_наличные;номер кассовой смены
 *  Число 1 указывает, что следующие два параметра содержат количество наличных платежей и их сумму в копейках.
 *  Пример: «1;55;20010000;2334» - означает, что за смену было 55 оплат наличными на общую сумму 200100.00 руб, номер кассовой смены 2334.
 *  Параметр номер смены ккм используется для контроля уникальности, если в течении смены выполнялось несколько сверок итогов.
 *  @return int Код ошибки.
 */
PILOT_NT_API int close_day_info(struct auth_answer *auth_answer, const char* iParams);

/** @brief Получение текущего отчета за текущую смену
 *  @param[in, out] auth_answer См. auth_answer. При значении поля TType = 0 формируется полный отчет, иначе - краткий
 *  @return int Код ошибки.
 */
PILOT_NT_API int get_statistics(struct auth_answer *auth_answer);

/** @brief Получение номера версии библиотеки pilot_nt.dll
 *  @return Версия как целое число в формате 0x00VVRRBB. VV - версия, RR - релиз, BB - сборка
 */
PILOT_NT_API unsigned int GetVer();

 /** @brief Установить конфигурационные параметры в pinpad.ini
 *  @param[in] pConfData Строка формата param1=value1;...paramN=valueN;
 *  @return int Код ошибки.
 */
PILOT_NT_API int SetConfigData(const char* pConfData);

/** @brief Деинициализация библиотеки pilot_nt.dll
 *  @note Выполняется отключение от библиотеки gate.dll
 */
PILOT_NT_API void Done();

/** @brief Асинхронное включение чтения карты
 *  @param[in] hDestWindow Хендл окна, которое будет получать сообщения о чтении карты
 *  @param[in] message Идентификатор сообщение о чтении карты
 *  @return int Код ошибки.
 */
PILOT_NT_API int EnableReader (HWND hDestWindow, UINT message);

/** @brief Асинхронное выключение чтения карты
 *  @return int Код ошибки.
 */
PILOT_NT_API int DisableReader();

/** @brief Проверка готовности пинпада
 *  @note Функция проверяет наличие пинпада. При успешном выполнении возвращает 0 (пинпад подключен), при неудачном – код ошибки (пинпад не подключен или неисправен).
 *  @return int Код ошибки.
 */
PILOT_NT_API int TestPinpad();

/** @brief Функция переводит последнюю успешную транзакцию в «подвешенное» состояние. Если транзакция находится в этом состоянии, то при следующем сеансе связи с банком она будет отменена..
 *  @note Функция сверяет переданные извне параметры (сумму и код авторизации) со значениями в последней успешной операции, которая была проведена через библиотеку. Если хотя бы один параметр не совпадает, функция возвращает код ошибки 4140 и не выполняет никаких действий.
 *  @warning Не поддерживается при работе по протоколу ТТК.
 *  @param dwAmount Сумма операции (в копейках)
 *  @param pAuthCode Код авторизации.
 *  @return int Код ошибки.
 */
PILOT_NT_API int SuspendTrx (DWORD dwAmount, char* pAuthCode);

/** @brief Функция возвращает последнюю успешную транзакцию в «нормальное» состояние.
 *  После этого транзакция будет включена в отчет и спроцессирована как успешная.
 *  Перевести ее снова в «подвешенное» состояние будет уже нельзя.
 *  @note Функция сверяет переданные извне параметры (сумму и код авторизации) со
 *  значениями в последней успешной операции, которая была проведена через библиотеку.
 *  Если хотя бы один параметр не совпадает, функция возвращает код ошибки 4140 и не выполняет никаких действий.
 *  @warning Не поддерживается при работе по протоколу ТТК.
 *  @param dwAmount Сумма операции (в копейках)
 *  @param pAuthCode Код авторизации.
 *  @return int Код ошибки.
 */
PILOT_NT_API int CommitTrx  (DWORD dwAmount, char* pAuthCode);

/** @brief Функция вызывает немедленную отмену последней успешной операции
 *  @note Операция может быть предварительно возможно, ранее
 *  переведенную в «подвешенное» состояние, хотя это и не обязательно). Если транзакция уже
 *  была возвращена в «нормальное» состояние функцией CommitTrx(), то функция RollbackTrx()
 *  завершится с кодом ошибки 4141, не выполняя никаких действий. Функция сверяет переданные
 *  извне параметры (сумму и код авторизации) со значениями в последней успешной операции,
 *  которая была проведена через библиотеку. Если хотя бы одинпараметр не совпадает, функция
 *  возвращает код ошибки 4140 и не выполняет никаких действий.
 *  @warning Не поддерживается при работе по протоколу ТТК.
 *  @param dwAmount Сумма операции (в копейках)
 *  @param pAuthCode Код авторизации.
 *  @return int Код ошибки.
 */
PILOT_NT_API int RollbackTrx(DWORD dwAmount, char* pAuthCode);

/** @brief Функция прерывает работу функций card_authorizeX()
 *  @note Внешнее ПО может вызвать эту функцию из отдельного треда, чтобы досрочно прекратить выполнение любой из функций card_authorize…(). При этом функция card_authorize…()  завершится с кодом ошибки 2000 (операция прервана).
 *  @warning Используется только в вендинговых решениях.
 *  @return int Код ошибки.
 */
PILOT_NT_API int AbortTransaction();

/** @brief Функция передает в терминал торговый чек
 *  @note Максимальный размер торгового чека 62 КБ. Описание в разделе \ref page6
 *  @param dwQueryRequestID Уникальный идентификатор операции (requestID в ответе финансовой операции)
 *  @param pCheque Указатель на строку с торговым чеком
 *  @warning Используется только в торговых решениях PCI DSS.
 *  @return int Код ошибки.
 */
PILOT_NT_API int AddMerchantCheque(DWORD dwQueryRequestID, const char* pCheque);
/**@}*/

/**
 * @defgroup READCARD Чтение карты
 */
/**@{*/
/** @brief Чтение карты
 *  @param Last4Digits Буфер, куда функция записывает четыре последних цифры номера карты. Размер буфера должен быть не менее 5 байт.
 *  @param Hash Хеш от номера карты, в формате ASCII с нулевым байтом в конце. Размер буфера должен быть не менее 41 байта.
 *  @return int Код ошибки.
 */
PILOT_NT_API int ReadCard  (char *Last4Digits, char *Hash);

/** @brief Функция позволяет прочитать банковскую карту для использования в скидочной системе «Спасибо от Сбербанка».
 *  @note Карта должна быть выдана Сбербанком, в противном случае функция вернет ошибку.
 *  @param Last4Digits Буфер, куда функция записывает четыре последних цифры номера карты. Размер буфера должен быть не менее 5 байт.
 *  @param Hash Хеш от номера карты, в формате ASCII с нулевым байтом в конце. Размер буфера должен быть не менее 41 байта.
 *  @return int Код ошибки.
 */
PILOT_NT_API int ReadCardSB(char *Last4Digits, char *Hash);

/** @brief Чтение карты
 *  @param Last4Digits Буфер, куда функция записывает четыре последних цифры номера карты. Размер буфера должен быть не менее 5 байт.
 *  @param Hash Хеш от номера карты, в формате ASCII с нулевым байтом в конце. Размер буфера должен быть не менее 41 байта.
 *  @param pCardType Тип карты. См. ::CardTypes
 *  @param pIsOwnCard Признак "Карта выпущена Сбербанком"
 *  @return int Код ошибки.
 */
PILOT_NT_API int ReadCardWithType(
  char *Last4Digits,
  char *Hash,
  int*  pCardType,
  int*  pIsOwnCard
);

/** @brief Чтение карты
 *  @param PAN Буфер, куда функция записывает PAN карты
 *  @param Hash Хеш от номера карты, в формате ASCII с нулевым байтом в конце. Размер буфера должен быть не менее 41 байта.
 *  @param pCardType Тип карты. См. ::CardTypes
 *  @param pIsOwnCard Признак "Карта выпущена Сбербанком"
 *  @return int Код ошибки.
 */
PILOT_NT_API int ReadMaskedCardWithType(
  char *PAN,
  char *Hash,
  int*  pCardType,
  int*  pIsOwnCard
);

/** @brief Чтение полной второй дорожки карты
 *  @note  Данные второй дорожки могут иметь длину до 40 символов.
 *  Вторая дорожка имеет формат:
 *    nnnn...nn=yymmddd...d
 *  где     '=' - символ-разделитель
 *      nnn...n - номер карты
 *      yymm    - срок действия карты (ГГММ)
 *      ddd...d - служебные данные карты
 *  @param[out] Track2 Буфер на 41 байт.
 *  @return int Код ошибки.
 */
PILOT_NT_API int ReadTrack2(char *Track2);

/** @brief Чтение полной третьей дорожки карты
 *  @note Данные третьей дорожки могут иметь длину до 40 символов.
 *  @param[out] Last4Digits 4 последние цифры карты
 *  @param[out] Hash Хеш от номера карты, в формате ASCII с нулевым байтом в конце. Размер буфера должен быть не менее 41 байта.
 *  @param[out] pTrack3 третья дорожка карты
 *  @return int Код ошибки.
 */
PILOT_NT_API int ReadCardTrack3(char *Last4Digits, char *Hash, char* pTrack3);

/** @brief Чтение карты Сберкарт
 *  @param[out] CardNo полный номер карты
 *  @param[out] ClientName имя фамилия клиента эмброссированные на карте
 *  @return int Код ошибки.
 */
PILOT_NT_API int ReadSbercard(char *CardNo, char* ClientName);

/** @brief Чтение карты Сберкарт
 *  @param[out] pTrack2 Track2
 *  @param[out] ValidThru Срок действия карты в формате YYMM
 *  @param[out] pName имя фамилия клиента эмброссированные на карте
 *  @return int Код ошибки.
 */
PILOT_NT_API int ReadCardAndName(
  char *pTrack2,
  char* ValidThru,
  char* pName
);

/** @brief Чтение карты
 *  @note  Чтобы использовать результат для авторизации, их нужно будет сформатировать так "CardNo=ValidThru".  
 *  Функция не поддерживается по протоколу TTK для PCI-DSS решений.
 *  @param CardNo Номер карты. Может иметь длину от 13 до 19 цифр.
 *  @param ValidThru Срок действия карты в формате YYMM
 *  @return int Код ошибки.
 */
PILOT_NT_API int ReadCardFull(char *CardNo, char *ValidThru);

/** @brief Чтение карты
 *  @param dataOut Контекст операции, в которую копируются pan, хэш, тип карты, признак "Карта выпущена Сбербанком" и номер программы лояльности
 *  @return int Код ошибки.
 */
PILOT_NT_API int ReadCardContext(CONTEXT_PTR dataOut);

 /** @brief Задать вопрос держателю карты и получить ответ введенный на клавиатуре пинпада.
  *  @note Вопрос может состоять из предопредленных значений. Например "phone" для ввода телефонного номера,
  *  "email" для ввода адреса электронной почты
  *  @param[in]     question     Вопрос, либо предопреденное значение (phone или email).
  *  @param[in|out] answer       Ответ владельца карты. Может содержать значение по умолчанию.
  *  @param[in]     answerLength Длина буфера для ответа.
  *  @return int Код ошибки.
 */
PILOT_NT_API int AskCardHolderAbout(const char* question, char* answer, unsigned answerLength);

/**@}*/

/**
 * @defgroup VENDING Вендинговые операции
 */
/**@{*/
 /** @brief Установить элементы для вывода на экран
 *  @param[in] hText Элемент вывода текста.
 *  @param[in] hEdit Элемент ввода текста.
 *  @return int Код ошибки.
 */
PILOT_NT_API int SetGUIHandles(int hText, int hEdit);

/** @brief Извлечь карту. Команда 5020.
 *  @return int Код ошибки.
 */
PILOT_NT_API int EjectCard();

/** @brief Перемещение карты в лоток для задержанных карт. Команда 5021.
 *  @return int Код ошибки.
 */
PILOT_NT_API int CaptureCard();

/** @brief Проверка наличия карты в чиповом считывателе.
 *  @return int Код ошибки. 0 - карта внутри ридера, готова к работе; 254 - карты нет; 251 - карта в устье ридера, ожидает, что ее заберет клиент
 */
PILOT_NT_API int TestCard();

/** @brief Открыть клавиатуру в нешифрованном режиме
 *  @return int Код ошибки.
 */
PILOT_NT_API int OpenKeyboard();

/** @brief Закрыть клавиатуру
 *  @return int Код ошибки.
 */
PILOT_NT_API int CloseKeyboard();

/** @brief Получить код нажатого символа без ожидания
 *  @return int Возвращается 0, если нажатия клавиши не было.
 */
PILOT_NT_API int ReadKeyboard();

/** @brief Протестировать готовность оборудования
 *  @return unsigned char Возвращает битовую маску.
 - 0x00 ни пинпад, ни картридер не готов
 - 0x01 готов только пинпад
 - 0x02 готов только картридер
 - 0x03 готов и пинпад, и картридер
 */
PILOT_NT_API unsigned char TestHardware();
 /** @brief Чтение ответа сообщения мониторинга
  *  @param[in] hostType Может иметь значения "1" для мониторинга HELIOS или "2" для мониторинга PSDB.
  *  @param[out] host_answ см. структуру host_status_answer
  *  @return int Код ошибки.
 */
PILOT_NT_API int PilotGetHostStatus(int hostType, struct host_status_answer *host_answ);
/** @brief Выполнить операцию CloseReader для сброса заставки ожидания на пинпаде (sb_pilot 31)
 *  @return int Возвращает код ошибки.
 */
PILOT_NT_API int PilotCloseReader();
/**@}*/

/**
 * @defgroup CONTEXT Функции работы с контекстом
 */
/**@{*/
 /** @brief Создать контекст операции. Функция создает пустой контекст операции.
  *  @note Для входного контекста значения параметров устанавливаются вызывающей программой, для выходного контекста значения параметров устанавливаются библиотекой.
  *  При повторном использовании контекста, если переменная уже есть в контексте, она будет перезаписана. Рекомендуется либо создавать и удалять контексты при каждой
  *  операции, либо очищать контекст вызовом функции ctxClear перед повторным использованием.
  *  @return CONTEXT_PTR Идентификатор контекста операции или 0, если произошла ошибка
 */
PILOT_NT_API CONTEXT_PTR ctxAlloc(void);

 /** @brief Удалить контекст операции
  *  @param[in] ctx Идентификатор контекста.
  *  @return нет
 */
PILOT_NT_API void ctxFree(CONTEXT_PTR ctx);

 /** @brief Отчистить контекст. Функция удаляет все параметры из контекста.
  *  @param[in] ctx Идентификатор контекста.
  *  @return нет
 */
PILOT_NT_API void ctxClear(CONTEXT_PTR ctx);

 /** @brief Записать в контекст значение строкового параметра.
  *  @param[in] ctx  Идентификатор контекста.
  *  @param[in] name Идентификатор параметра.
  *  @param[in] str  Указатель на строку.
  *  @return int Код ошибки.
 */
PILOT_NT_API int ctxSetString(CONTEXT_PTR ctx, EParameterName name, const char* str);

 /** @brief Записать в контекст значение целочисленного параметра.
  *  @param[in] ctx  Идентификатор контекста.
  *  @param[in] name Идентификатор параметра.
  *  @param[in] val  Значение параметра.
  *  @return int Код ошибки.
 */
PILOT_NT_API int ctxSetInt(CONTEXT_PTR ctx, EParameterName name, int val);

 /** @brief Записать в контекст значение параметра в виде последовательности байт.
  *  @param[in] ctx  Идентификатор контекста.
  *  @param[in] name Идентификатор параметра.
  *  @param[in] val  Указатель на буфер.
  *  @param[in] sz   Длина буфера.
  *  @return int Код ошибки.
 */
PILOT_NT_API int ctxSetBinary(CONTEXT_PTR ctx, EParameterName name, unsigned char* val, int sz);

 /** @brief Считать из контекста значение переменной в виде строки.
  *  @note Для целочисленной переменной вы получите ее строковое представление, а для последовательности байт функция вернет hex строку.
  *  @param[in] ctx  Идентификатор контекста.
  *  @param[in] name Идентификатор параметра.
  *  @param[in] val  Указатель на строку.
  *  @param[in] sz   Максимально возможная длина строки.
  *  @return int Код ошибки.
 */
PILOT_NT_API int ctxGetString(CONTEXT_PTR ctx, EParameterName name, char* str, int sz);

 /** @brief Считать из контекста значение переменной в виде целого числа.
  *  @note Для строковой переменной будет выполнено преобразование строки в число, для последовательности байт
  *  функция преобразует первые четыре байта последовательности в целое число с прямым порядком байт.
  *  @param[in] ctx  Идентификатор контекста.
  *  @param[in] name Идентификатор параметра.
  *  @param[in] pVal Указатель на число.
  *  @return int Код ошибки.
 */
PILOT_NT_API int ctxGetInt   (CONTEXT_PTR ctx, EParameterName name, int* pVal);

 /** @brief Считать из контекста значение переменной в виде последовательности байт.
  *  @note Для строковой переменной будет значение будет возвращено без изменения, для целочисленной переменной функция
  *  вернет последовательность из четырех байт с прямым порядком байт.
  *  @param[in] ctx     Идентификатор контекста.
  *  @param[in] name    Идентификатор параметра.
  *  @param[in] pVal    Указатель на буфер результата.
  *  @param[in] pOutSz  Количество байт, скопированных в буфер.
  *  @param[in] MAXSIZE Максимально возможное количество байт.
  *  @return int Код ошибки.
 */
PILOT_NT_API int ctxGetBinary(CONTEXT_PTR ctx, EParameterName name, unsigned char* pVal, int* pOutSz, int MAXSIZE);
/**@}*/

#pragma pack()

#ifdef __cplusplus
};
#endif

#endif // _PILOT_NT_H_







